> keyword: <br>쿠키, 세션, 토큰, JWT(+Header-Payload-Signature), Access Token - Refresh Token

## 쿠키, 세션, 토큰

서버가 클라이언트 인증을 확인하는 3가지 방식이 바로 쿠키, 세션, 토큰입니다.

### 쿠키
Key-Value 형식의 문자열 덩어리입니다.
> Cookie : fa;dshabsdfgasfds;

이런 느낌이죠.

쿠키는 1) 각 사용자마다의 브라우저에 사용자의 정보를 저장해 2) 이후 사용자를 식별하는데 해당 쿠키를 사용합니다.

쿠키가 저장되는 방식은 다음과 같습니다.

1. 클라이언트가 어떤 웹사이트를 방문하게 되면(브라우저를 통하겠죠?) 브라우저가 서버에 요청을 보냅니다.
2. 사이트가 사용하는 서버는 클라이언트의 요청에 대한 응답을 작성합니다.
3. 그 때 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담습니다. (클라이언트의 브라우저에 작은 기록 정보 파일이 설치되죠)
4. 이후 클라이언트가 요청을 보낼 떄마다(=접속할 때마다) 브라우저에 저장된 쿠키를 요청 헤더의 쿠키에 담아 보냅니다.
5. 서버는 쿠키에 담긴 정보를 바탕으로 이 요청의 클라이언트는 누구인지 식별하고, 또 정보를 바탕으로 추천 광고를 띄웁니다.

문제점은 딱 봐도 이런게 있겠다 싶죠? 맞습니다.

1. 보안 이슈: 취약 - 유출 & 조작 당할 위험 ↑
2. 브라우저간 공유가 불가능합니다.<br> 왜죠? 브라우저마다 쿠키 지원 형태가 다릅니다.
3. 용량 제한이 있습니다 (작은 정보를 각 브라우저에 저장하다 보니)
4. 용량 제한이 있더라도, 사이즈가 커질수록 네트워크에 부하가 걸립니다. 다들 응답속도 끌어올리겠다고 브라우저에 저장된 쿠키 삭제는 해 보셨죠?

### 세션

TRPG 세션 아님

비밀번호 같은 민감한 정보(from Client)를 서버에서 저장 + 관리합니다.

1. 유저가 로그인하면 세션을 저장 (서버 메모리상에 저장)<br>How? 세션 식별용 Session ID 기준으로 저장.
2. 서버: 브라우저 쿠키에 Session ID 저장.
3. 쿠키에 정보가 담겨있죠? 브라우저(from Client)는 해당 사이트에 대한 모든 요청을 보내겠죠? 그 때 Session ID를 쿠키에 끼워넣어서 전송
4. 서버: 클라이언트가 보낸 Session ID vs 서버 메모리 관리하는 Session ID를 비교, 인증을 수행합니다.

보다시피, 보안은 괜찮아 보이죠? 이슈도 당연히 보이고.

1. 세션 ID 탈취당하면(따잇) 큰일.
2. 그래도 쿠키 포함한 요청이 외부에 노출될지언정 세션 ID 자체가 정보를 담지 않음
3. 서버 부하: 세션 저장소를 사용하고, 요청이 많아지면 그만큼 서버에 부하가 걸리죠

### 토큰

세션 아이디가 토큰으로 바뀐 것 같지만 조금 다릅니다.

요약: 인증받은 사용자에게 토큰을 발급/부여 → 상호 비교해서 

1. 토큰 발급: 인증 성공한 사용자에게 서버가 토큰을 발급.
2. 사용자(=클라이언트)는 이후 요청 시 요청 헤더Header에 토큰을 포함시켜 서버로 전송한다. (헤더가 뭔데? 일단 그건 밑에서 JWT 설명할 때 포함해서 할게요)
3. 서버 검증 과정: 1) 서버는 요청에 포함된 토큰을 확인하고 2) 서버가 기존에 발급했던 토큰과 일치 여부를 검증 → 인증 처리

헤더 내용 서명 등은 밑에서 설명할거에요~ 보다시피 쿠키랑 세션이랑 섞은거 같죠? 장단점 갑니다

1. 저장 위치: ≠ 세션. 토큰은 클라이언트(브라우저, 앱 등)에 저장 → 서버 부담 ↓
2. 빠른 인증 가능: 토큰 내부에 사용자 정보 등의 데이터를 포함하고, 서버는 토큰의 위조/변조 여부만 검증하면 되기에 빠르게 인증이 가능함.
3. 앱도 가능!: 앱에선 쿠키, 세션이 사용되지 않아용 → 토큰 방식이 일반적으로 사용
4. But.... 토큰의 데이터 길이가 길어서 요청이 많다면? 네트워크 부하 ↑
5. 내용(Payload, 또는 본문)부분은 암호화 X → 중요한 정보는 포함되지 않아야 함.
6. 토큰 탈취되면? 보안 위험! 그래서 유효 기간(=만료 시간)을 설정해 둡니다.

## JWT

<strong>JSON Web Token.</strong><br>
T는 토큰, J는 JSON, W는 웹. 그러면 다른 종류의 토큰도 있을것 같아요.

세 부분으로 구성됩니다: `헤더Header`<b> . </b>`내용Payload`<b> . </b>`서명Signature`

- 헤더Header : JWT에서 사용할 타입, 해시 알고리즘 종류가 들어간다.
- 내용Payload: (Claim = 정보의 조각)서버에서 첨부한 사용자 권한 정보, 데이터가 들어간다.
- 서명Signature: 개인키로 전자서명이 들어간다. 헤더에서 정의한 알고리즘 방식을 서명에서 사용. (<헤더 + 페이로드> + 서버 보유 유일 Key값) ← 을 헤더 정의 알고리즘으로 암호화 하면 이게 서명입니다!

<details><summary>Payload: Registered, Public, Private</summary>클레임에도 3종류가 있습니다<br><br>Registered: 미리 정의된 클레임<br><br>Public: 사용자가 정의할 수 있는 클레임 for 공개용 정보 전달<br><br>Private: 사용자가 지정할 수 있는 클레임 for 해당 당사자 간 정보 공유하기 위해 만들어진 것. 외부 공개? 해도 되긴 하겠지만 해당 유저 특정할 수 있는 정보가 담겨있음. </details>

### Access - Refresh

AT RT라고 적으려고했다가 이게 뭔말인가 싶어서..

<strong>Access Token</strong>: 유저의 정보가 담긴 토큰 (클라이언트가 가지고 있음). <br> 수명을 짧게 만듭니다 - Why? 해당 토큰이 만료되기 전까지, 이 토큰을 획득한 사람은 누구나 권한 접근이 가능합니다. 그래서 짧게 만들어야 탈취되더라도 일회성 느낌으로 사용 가능하게 되는것.<br>수명 더 짧게 만들수록, 유저는 그만큼 로그인을 더 많이 해야하는 문제도 같이 발생.

<strong>Refresh Token</strong>: 새로운 Access Token을 발급해주기 위해 사용하는 것. 짧은 수명 가지는 Access Token이 문제이기 때문에 새로운 토큰을 발급해주려고 제공합니다.
